# プロジェクトのゴール

CSVデータを読み取り、特定のカラムに対して自動的にunpivotのような転回を行うライブラリ

このツールは kintone の export する CSV ファイルの構造が SQL と極めて相性が悪いため、これに対処することを目的とする

# 秘密情報の取り扱い

## 開発時

 * 一般的な秘密情報はコミットしない

# 利用ツールについて

## 言語と記法について

 * TypeScriptで書く
 * TypeScriptで型定義を行う。加えて、Google Apps Scriptのような.d.tsを利用できないJavaScript環境でのコード補完などを考慮し、JSDocコメントでも型情報を記述する。
 * JavaScript Standard Lintルールに従う
    * stnadard compliantかどうかはstanadlone binaryとeslint-config-standardを利用して判断する
    * stanadlone binaryでの動作を考慮し、一部ルールの無視などの制御はeslintrcではなくコードコメントで行う
    * no-unused-varsはfunction, class定義行でコメントで無視し、no-undefはglobal定義で無視する
 * arrow functionの引数を受け取る括弧は省略しない
 * 開発時のローカルのruntimeにはDenoを利用する

## コード配置

 * 基本的に src/ 以下にプロダクトコードを置く
 * spec/ 以下にテストコードおよびテスト用のサンプルデータや支援ツールを置く

## バンドラ、テスト、デプロイについて

 * テストにはVite, Vitest, power-assert を利用し、デプロイの前にテストを実施する
    * テストタスクは `deno task -q test` で実行することで同期的に出力を得る
 * CIにはGitHub Actionsを利用する

## 一般的なコードの設計指針

 * 変数はconstで宣言し、immutableなものとして扱う（テストは除く）
 * 関数はできるだけ短く、シンプルに、単一責務になるように設計する。目安として10行程度とするが、処理の性質上やむを得ない場合はこの限りではない。
 * 関数の名前はその役割をよく表すものにする
 * 関数の中身はできるだけ再利用可能にする
 * 関数の中身はできるだけテストしやすくする
 * DRY原則に従う
 * 依存性は外部から注入する
 * I/Oを扱う以外の理由での例外の利用を禁止する
    * 例外のブロックは必要な箇所のみを対象とし、関数全体が例外処理になるような設計は避ける
 * コメントはファイルの先頭や関数定義部のブロックコメントとして記述することを基本とする。ただし、関数内で処理の意味が異なるブロックの開始位置に、そのブロックの目的を説明するインラインコメントを記述することを許可する。
    * 特別な注意が必要な場合とtype定義の場合を除く
 * 関数の中で処理の意味が異なる場合は以下のように扱う
    * 名前を付けて関数を分離できるなら分離する
    * 分離するほどではないが処理の種類や意味がやや異なることを表したい場合は空行を設ける

## プロジェクト固有の設計指針

基本的な機能を以下の二つに分けて考える

 1. CSVファイルの読み取り、パースし、JavaScriptオブジェクトにする
 2. 読み取ったCSVに基づくオブジェクトに対して、定義に基づいて一部のカラムを1:n結合のrelation先のtableをjoinしたかのように複数のレコードに転回する

1 と 2 を混ぜない。これは 2 の部分を特定のプラットフォームに依存させないため。

### 基本的な変換ルール

 * kintoneはアプリという単位があり、これがRDBMSで言うtableのようなものに該当する
    * しかしこのアプリのデータの中にtableという固有の型があり、これはtableの入れ子を実現できる
 * kintone固有のtable型があった場合、これをRDBMSで言う別tableに分割、正規化を行う
 * 複数選択可能なカラムがあった場合、カラムが増えて "カラム名[選択肢]" という名前になるが、これを1:nで別tableに分けたうえでjoinしたのと同様の形になるようにレコードを増やす形（直積）で実現する。カラム名は元の定義にある "カラム名" とする

### Table定義、複数選択カラム定義

```javascript
{
  tableDefinitions: {
    table1: ['col1', 'col2']
  },
  multiChoiceColumns: {
    main: ['mc1']
  }
}
```

 * TableDefinitions: テーブル定義 `Record<TableName, ColumnName[]>`
    * `テーブル名: 'カラム名'[]` 構造の object で作成
      * テーブル名は適当でよいが、アプリケーション全体を表すものは main と呼ぶ
    * テーブル定義は main については省略できる（他のtableで指定されていないカラムがすべてmain扱いになる）
      * このため、何も設定しなくても一応動作する（目的は果たさない）
      * 与えられたデータに対して無視したいカラムがある場合は main テーブルの定義を作るとよい
 * MultiChoiceColumns: 複数選択カラム定義 `Record<TableName, ColumnName[]>`
    * 形式は TableDefinitions と同じだが、main テーブル以外の table がある場合は TableDefinitions と重複で設定することになる（TableDefinitions はカラムの順番を維持するために利用している）

### 変換例

#### original

Record number | テキスト1 | col1       | col2      | mc1[opt1] | mc1[opt2]
--------------|----------|------------|-----------|-----------|----------
1             | あああ    | テーブル内1 | テーブル内2 | 1         | 1

#### after

`records`

Record number | テキスト1 | mc1
--------------|----------|------
1             | あああ    | opt1
1              | あああ    | opt2

`table1`

Record number | col1      | col2
--------------|-----------|-----------
1             | テーブル内1 | テーブル内2
